# Neural Guided Constraint Logic Search For Neural Network Architectures

--- high level example --- noTangle
(run (a b) (appendo a b '(1 2 3 4)))
---

With typical miniKanren's typical search strategy, that would output:

--- example appendo output --- noTangle
`(() (1 2 3 4)
  (1)  (2 3 4)
  (1 2)  (3 4)
  (1 2 3)  (4)
  (1 2 3 4) ())
---

Imagine we want a search strategy that, instead, outputs the results with a preference towards results where `a` and `b` have the same length. For example:

--- example appendo output with preference for equal-length `a` and `b` --- noTangle
`((1 2)  (3 4)
  (1)  (2 3 4)
  (1 2 3)  (4)
  () (1 2 3 4)
  (1 2 3 4) ())
---

How would we change miniKanren to allow that?

We need a way to, when faced with a choice (a disjunction), ask some external system which path of the disjunction we should take in order to arrive at our results in the desired order.

Since `step` is the function that handles re-ordering disjunctions, we'll need to be able to give `run` a custom `step` function.

--- high level example --- noTangle
(run step (a b) (appendo a b '(1 2 3 4)))
---

`step` is going vary based on which "path chooser" we are using. If we want `step` to reach out to `sdtin` for decisions, that will be one possible `step` function that we'd pass in. But if we want it to reach out to a separate process which is running a neural network to make decisions, then that would be a different `step` function.

The original miniKanren run looks like this:

--- run --- noTangle
(define-syntax run
  (syntax-rules ()
    ((_ n body ...) (map reify/initial-var (stream-take n (query body ...))))))
---

Since we need a custom `step` function, we'll need to make a slight adjustment.

--- run/step --- noTangle
(define-syntax run/step
  (syntax-rules ()
    ((_ n step body ...) (map reify-initial-var (stream-take n step (query body ...))))))
---

Which means we'll need a custom `stream-take`.

The original `stream-take` looks like this:

--- stream-take --- noTangle
(define (stream-take n s)
  (if (eqv? 0 n)
      '()
      (let ((s (mature s)))
        (if (pair? s)
            (cons (car s) (stream-take (and n (- n 1)) (cdr s)))
            '()))))
---

--- stream-take/step --- noTangle
(define (stream-take/step step n s)
  (if (eqv? 0 n)
      '()
      (let ((s (mature/step step s)))
        (if (pair? s)
            (cons (car s) (stream-take/step step (and n (- n 1)) (cdr s)))
            '()))))
---

`mature` is the thing that calls `step` until we get to a terminal (one of n results, or a failure).

I'm going to take a break right here from going into every little detail step-by-step.

[Greg Rosenblatt's first-order-miniKanren](https://github.com/gregr/first-order-miniKanren) already gives us all of those `<foo>/step`-like functions. We don't need any changes to that system. The only thing we need to do is define our custom chooser.

TODO: With one small caveat. It's not related to the `step` stuff. It's related to how the results are produced. I think we'd benefit from having the results streamed to some external process, rather than accumulated with `cons` and returned at the end. We're going to be searching an infinite search space (all possible neural network architectures) and we want to be able to train on results as the search is ongoing (or, just in general, have access to the results before an infinite search never finishes).

Ok.

So.

If the only thing we need to change (ignoring that TODO for a moment) is the `step` function, then what will our custom `step` look like?

--- step that asks for disj decision
(define (stepper choose)
  (lambda (s)
    (match s
     ((mplus s1 s2)
      (let ((s1 (simplify s1))
            (s2 (simplify s2)))
        (cond
         ((not s1) s2)
         ((pair? s1)
          (cons (car s1)
                (mplus (cdr s1) s2)))
         (else
          (let ((path (choose s1 s2)))
            (if (eq? 'left path)
              (mplus (step s1) s2)
              (mplus (step s2) s1)))))))
     ((bind s g)
      (cond
       ((not s) #f)
       ((pair? s)
        (mplus (pause (car s) g)
               (bind (cdr s) g)))
       (else (bind (step s) g))))
     ((pause st g) (start st g))
     (_ s))))
---

(It's kind of weird that, when you `step` `'left`, the streams get re-ordered, such that to `step` down that path again you subsequently need to `step` `'right`. But it's not a trival fix because then we need to handle the case where `s2` is a pair. I just don't want to deal with that right now. But it would be nice, eventually.)

### Path-choosers

--- stdin path chooser
(define (stdin-chooser s1 s2)
  (printf "left:~n~a~n" (pp/stream 0 s1))
  (printf "right:~n~a~n" (pp/stream 0 s2))
  (printf "left or right? ")
  (do ((user-input (string->symbol (read-line))
                   (begin
                     (printf "~a is an invalid input~n" user-input)
                     (printf "left or right? ")
                     (string->symbol (read-line)))))
      ((or (eq? user-input 'left) (eq? user-input 'right)) user-input)))
---

### Test

--- /test.rkt
#lang racket/base
(require
  (only-in racket/match match)
  first-order-miniKanren/microk-fo
  first-order-miniKanren/tools
  "pprint.rkt"
  "simplify.rkt")

@{step that asks for disj decision}
@{stdin path chooser}

(define step (stepper stdin-chooser))

(define-relation (appendo a b ab)
  (conde
   ((== a '()) (== b ab))
   ((fresh (a1 a2 res)
      (== a `(,a1 . ,a2))
      (== ab `(,a1 . ,res))
      (appendo a2 b res)))))

(run/step step 2 (a b) (appendo a b '(1 2 3 4)))
---


--- /neural-architecture-search.rkt
#lang racket/base

(require
@{requires}
)

@{step that asks for disj decision}
@{stdin path chooser}
@{start}
---

## Choosing Which Path To Explore

At a high-level, we want to use the existing first-order miniKanren implementation with one minor change: we want `mature` to step until it gets to a disjunction, and then we want to ask another process which path we should take.

QUESTION: What information will the decision-making process need? Will it have everything it needs in the disjuction? Will we need to expand the children of the disjunction to get more information? Will we need to keep track of the path we took to get to the disjunction (all of the conjuctions along the way)?

### Step

The typical implementation `step`s `s1`, early, if it's not `#f` or a `pair`.

```
(let ((s1 (if (mature? s1) s1 (step s1))))
     ...)
```

We don't know if we want to `step` `s1` or `s2` until we ask `choose`, our decision-maker. So, we have to modify `step` a little bit.

--- step that asks for disj decision v1
(define (stepper choose)
  (lambda (s)
    (match s
     ((mplus s1 s2)
      (cond
       ((not s1) s2)
       ((pair? s1)
        (cons (car s1)
              (mplus (cdr s1) s2)))
       (else
        (let ((path (choose s1 s2)))
          (if (eq? 'left path)
            (mplus (step s1) s2)
            (mplus (step s2) s1))))))
     ((bind s g)
      (cond
       ((not s) #f)
       ((pair? s)
        (mplus (pause (car s) g)
               (bind (cdr s) g)))
       (else (bind (step s) g))))
     ((pause st g) (start st g))
     (_ s))))
---

### Path-choosers

--- stdin path chooser v1
(define (stdin-chooser)
  (printf "left or right? ")
  (do ((user-input (string->symbol (read-line))
                   (begin
                    (printf "~a is an invalid input~n" user-input)
                    (printf "left or right? ")
                    (string->symbol (read-line)))))
      ((or (eq? user-input 'left) (eq? user-input 'right)) user-input)))
---

### Start

--- start
(define (start st g)
  (match g
    ((disj g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conj g1 g2)
     (step (bind (pause st g1) g2)))
    ((relate thunk _)
     (pause st (thunk)))
    ((== t1 t2) (state->stream (unify t1 t2 st)))
    ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolo t) (state->stream (typify t symbol? st)))
    ((stringo t) (state->stream (typify t string? st)))
    ((numbero t) (state->stream (typify t number? st)))
    ((not-symbolo t) (state->stream (distypify t symbol? st)))
    ((not-stringo t) (state->stream (distypify t string? st)))
    ((not-numbero t) (state->stream (distypify t number? st)))))
---



--- requires
(only-in racket/match match)
first-order-miniKanren/microk-fo
first-order-miniKanren/tools
racket/serialize
---
