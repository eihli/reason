#lang racket

(require
 "utils.rkt"
 "tools.rkt"
 "math.rkt")
(provide
 eval-expo)

(define-relation (caro a lst val)
  (== val `(,a . ,lst)))

(define-relation (ntho lst idx val)
  (conde
   ((== lst '()) (== val '()))
   ((fresh (cdr-val)
           (zeroo idx) (caro val cdr-val lst)))
   ((fresh (car-lst cdr-lst dec-i)
           (caro car-lst cdr-lst lst)
           (minuso idx '(1) dec-i)
           (ntho cdr-lst dec-i val)))))

(define-relation (reverseo xs ys)
  (reverse-accumulateo xs '() ys))

;; Helper relation that uses an accumulator
(define-relation (reverse-accumulateo xs acc ys)
  (conde
    ;; Base case: if the input list is empty, return the accumulator
    ((== xs '()) (== acc ys))
    ;; Recursive case: take the first element from the input list,
    ;; add it to the front of the accumulator, and continue with the rest
    ((fresh (head tail)
      (== `(,head . ,tail) xs)
      (reverse-accumulateo tail `(,head . ,acc) ys)))))

;; Extracts a substring [0, index) from a string (a list of symbols)
(define-relation (substro str index substring)
  (conde
    ((== index '()) (== substring '()))
    ((fresh (n-1 head tail suffix)
       (poso index)                        ; Ensure index is positive
       (== `(,head . ,tail) str)           ; Decompose string into head and tail
       (== `(,head . ,suffix) substring)   ; Add head to the substring
       (minuso index '(1) n-1)             ; Decrement index (index - 1)
       (substro tail n-1 suffix)))))       ; Continue with rest of string

(comment
 (run 1 (a b) (reverseo '(a b c) b))

 (run 1 (a b) (substro '(a b c d e f) '(1 1) b))
 ;; => '((_.0 (a b c)))

 )

(define-relation (eval-expo expr env value)
  (conde ;; NOTE: this clause order is optimized for quine generation.
   ((fresh (chars)
           (== `(s . ,chars) expr)
           (== expr value)))
   ((fresh (arg arg^ result)
           (== `(lower ,arg) expr)          ;; expr is a to-lowercase operation
           (eval-expo arg env `(s . ,arg^))
           (chars-to-lowero arg^ result)
           (== value `(s . ,result))))
   ((fresh (arg arg^ result)
           (== `(upper ,arg) expr)          ;; expr is a to-lowercase operation
           (eval-expo arg env `(s . ,arg^))
           (chars-to-uppero arg^ result)
           (== value `(s . ,result))))
   ((fresh (arg arg^ idx idx^ result)
           (== `(substr ,arg ,idx) expr)
           (eval-expo arg env `(s . ,arg^))
           (eval-expo idx env idx^)
           (substro arg^ idx^ result)
           (== value `(s . ,result))))
   ((fresh (arg arg^ result)
           (== `(reverse ,arg) expr)
           (eval-expo arg env `(s . ,arg^))
           (reverseo arg^ result)
           (== value `(s . ,result))))
   ((fresh (lst idx)
           (== `(nth ,lst ,idx) expr)
           (ntho lst idx value)))
   ((byteo expr)
    (== expr value))
   ((fresh (body)
           (== `(lambda ,body) expr)      ;; expr is a procedure definition
           (== `(closure ,body ,env) value)))
   ((fresh (rator rand arg env^ body)
           (== `(app ,rator ,rand) expr)  ;; expr is a procedure application
           (eval-expo rator env `(closure ,body ,env^))
           (eval-expo rand env arg)
           (eval-expo body `(,arg . ,env^) value)))
   ((fresh (index)
           (== `(var ,index) expr)        ;; expr is a variable
           (lookupo index env value)))
   ))

;; Lookup the value a variable is bound to.
;; Variables are represented namelessly using relative De Bruijn indices.
;; These indices are encoded as peano numerals: (), (s), (s s), etc.
(define-relation (lookupo index env value)
  (fresh (arg e*)
         (== `(,arg . ,e*) env)
         (conde
          ((== '() index) (== arg value))
          ((fresh (i* a d)
                  (== `(s . ,i*) index)
                  (== `(,a . ,d) e*)
                  (lookupo i* e* value))))))

;; This helper evaluates arguments to a list construction.
(define-relation (eval-listo e* env value)
  (conde
    ((== '() e*) (== '() value))
    ((fresh (ea ed va vd)
       (== `(,ea . ,ed) e*)
       (== `(,va . ,vd) value)
       (eval-expo ea env va)
       (eval-listo ed env vd)))))


(comment
 (run 1 (q) (eval-expo `(reverse (s A b)) '() q))

 (run 1 (q) (eval-expo `(substr (s b A) (1)) '() q))

 (run 1 (q) (eval-expo `(lower (s b A C)) '() q))

 (run 1 (q) (eval-expo `(lower (reverse (s b A))) '() q))

 (run 1 (q) (eval-expo `(reverse (lower (s b A))) '() q))

 (run 1 (q) (eval-expo `(lower (substr (s b A) (1))) '() q))

 (run 1 (q) (eval-expo `(reverse (substr (s b A) (1))) '() q))

 (run 1 (q) (eval-expo `(substr (reverse (s A b)) (1)) '() q))

 (run 1 (q) (eval-expo `(reverse (substr (s A b c d) (1 1))) '() q))

 (run 1 (q) (eval-expo `(reverse (substr (s A b c d) (1 1))) '() q))

 (run 1 (lambda)
      (eval-expo `(app ,lambda (s E r i c)) '() '(s c i r E))
      (eval-expo `(app ,lambda (s T a y l o r)) '() '(s r o l y a T))
      )

 (run 1 (lambda)
      (eval-expo `(app ,lambda (s E r i c)) '() '(s e r i c))
      (eval-expo `(app ,lambda (s T a y l o r)) '() '(s t a y l o r))
      )

 (run 1 (lambda)
      (== lambda `(lambda (reverse (lower (var ())))))
      (eval-expo `(app ,lambda (s E r i c)) '() '(s c i r e))
      (eval-expo `(app ,lambda (s T a y l o r)) '() '(s r o l y a t))
      )
 ;; => '(((lambda (reverse (lower (var ()))))))

 (run 1 (lambda)
      ;(== lambda `(lambda (substr (var ()) (1))))
      (eval-expo `(app ,lambda (s E r i c)) '() '(s E))
      (eval-expo `(app ,lambda (s T a y l o r)) '() '(s T))
      )
 )


(define-relation (byteo b)
  (conde
   ((== b '()))
   ((== b '(1)))
   ((== b '(0 1)))
   ((== b '(1 1)))
   ((== b '(0 0 1)))
   ((== b '(1 0 1)))
   ((== b '(0 1 1)))
   ((== b '(1 1 1)))
   ((== b '(0 0 0 1)))
   ((== b '(1 0 0 1)))
   ((== b '(0 1 0 1)))
   ((== b '(1 1 0 1)))
   ((== b '(0 0 1 1)))
   ((== b '(1 0 1 1)))
   ((== b '(0 1 1 1)))
   ((== b '(1 1 1 1)))
   ((== b '(0 0 0 0 1)))
   ((== b '(1 0 0 0 1)))
   ((== b '(0 1 0 0 1)))
   ((== b '(1 1 0 0 1)))
   ((== b '(0 0 1 0 1)))
   ((== b '(1 0 1 0 1)))
   ((== b '(0 1 1 0 1)))
   ((== b '(1 1 1 0 1)))
   ((== b '(0 0 0 1 1)))
   ((== b '(1 0 0 1 1)))
   ((== b '(0 1 0 1 1)))
   ((== b '(1 1 0 1 1)))
   ((== b '(0 0 1 1 1)))
   ((== b '(1 0 1 1 1)))
   ((== b '(0 1 1 1 1)))
   ((== b '(1 1 1 1 1)))
   ((== b '(0 0 0 0 0 1)))
   ((== b '(1 0 0 0 0 1)))
   ((== b '(0 1 0 0 0 1)))
   ((== b '(1 1 0 0 0 1)))
   ((== b '(0 0 1 0 0 1)))
   ((== b '(1 0 1 0 0 1)))
   ((== b '(0 1 1 0 0 1)))
   ((== b '(1 1 1 0 0 1)))
   ((== b '(0 0 0 1 0 1)))
   ((== b '(1 0 0 1 0 1)))
   ((== b '(0 1 0 1 0 1)))
   ((== b '(1 1 0 1 0 1)))
   ((== b '(0 0 1 1 0 1)))
   ((== b '(1 0 1 1 0 1)))
   ((== b '(0 1 1 1 0 1)))
   ((== b '(1 1 1 1 0 1)))
   ((== b '(0 0 0 0 1 1)))
   ((== b '(1 0 0 0 1 1)))
   ((== b '(0 1 0 0 1 1)))
   ((== b '(1 1 0 0 1 1)))
   ((== b '(0 0 1 0 1 1)))
   ((== b '(1 0 1 0 1 1)))
   ((== b '(0 1 1 0 1 1)))
   ((== b '(1 1 1 0 1 1)))
   ((== b '(0 0 0 1 1 1)))
   ((== b '(1 0 0 1 1 1)))
   ((== b '(0 1 0 1 1 1)))
   ((== b '(1 1 0 1 1 1)))
   ((== b '(0 0 1 1 1 1)))
   ((== b '(1 0 1 1 1 1)))
   ((== b '(0 1 1 1 1 1)))
   ((== b '(1 1 1 1 1 1)))))

(define (make-string s)
  `(s . ,(map (lambda (x) (string->symbol x)) (map string (string->list s)))))

(make-string "Eric Ihli")

(comment
 (run 20 (q) (stringo q))
 ;; => '(((list a)) ((list b)) ((list c)) ((list a a)) ((list d)) ((list a b)) ((list e)) ((list b a)) ((list f)) ((list g)) ((list h)) ((list b b)) ((list i)) ((list j)) ((list a c)) ((list k)) ((list l)) ((list a a a)) ((list m)) ((list n)))
 )

(define-relation (char-to-uppero a b)
  (conde
   ((== a `a) (== b `A))
   ((== a `b) (== b `B))
   ((== a `c) (== b `C))
   ((== a `d) (== b `D))
   ((== a `e) (== b `E))
   ((== a `f) (== b `F))
   ((== a `g) (== b `G))
   ((== a `h) (== b `H))
   ((== a `i) (== b `I))
   ((== a `j) (== b `J))
   ((== a `k) (== b `K))
   ((== a `l) (== b `L))
   ((== a `m) (== b `M))
   ((== a `n) (== b `N))
   ((== a `o) (== b `O))
   ((== a `p) (== b `P))
   ((== a `q) (== b `Q))
   ((== a `r) (== b `R))
   ((== a `s) (== b `S))
   ((== a `t) (== b `T))
   ((== a `u) (== b `U))
   ((== a `v) (== b `V))
   ((== a `w) (== b `W))
   ((== a `x) (== b `X))
   ((== a `y) (== b `Y))
   ((== a `z) (== b `Z))
   ((== a `A) (== b `A))
   ((== a `B) (== b `B))
   ((== a `C) (== b `C))
   ((== a `D) (== b `D))
   ((== a `E) (== b `E))
   ((== a `F) (== b `F))
   ((== a `G) (== b `G))
   ((== a `H) (== b `H))
   ((== a `I) (== b `I))
   ((== a `J) (== b `J))
   ((== a `K) (== b `K))
   ((== a `L) (== b `L))
   ((== a `M) (== b `M))
   ((== a `N) (== b `N))
   ((== a `O) (== b `O))
   ((== a `P) (== b `P))
   ((== a `Q) (== b `Q))
   ((== a `R) (== b `R))
   ((== a `S) (== b `S))
   ((== a `T) (== b `T))
   ((== a `U) (== b `U))
   ((== a `V) (== b `V))
   ((== a `W) (== b `W))
   ((== a `X) (== b `X))
   ((== a `Y) (== b `Y))
   ((== a `Z) (== b `Z))
   ((== a `0) (== b `0))
   ((== a `1) (== b `1))
   ((== a `2) (== b `2))
   ((== a `3) (== b `3))
   ((== a `4) (== b `4))
   ((== a `5) (== b `5))
   ((== a `6) (== b `6))
   ((== a `7) (== b `7))
   ((== a `8) (== b `8))
   ((== a `9) (== b `9))))

(define-relation (char-to-lowero a b)
  (conde
   ((== a 'a) (== b 'a))
   ((== a 'b) (== b 'b))
   ((== a 'c) (== b 'c))
   ((== a 'd) (== b 'd))
   ((== a 'e) (== b 'e))
   ((== a 'f) (== b 'f))
   ((== a 'g) (== b 'g))
   ((== a 'h) (== b 'h))
   ((== a 'i) (== b 'i))
   ((== a 'j) (== b 'j))
   ((== a 'k) (== b 'k))
   ((== a 'l) (== b 'l))
   ((== a 'm) (== b 'm))
   ((== a 'n) (== b 'n))
   ((== a 'o) (== b 'o))
   ((== a 'p) (== b 'p))
   ((== a 'q) (== b 'q))
   ((== a 'r) (== b 'r))
   ((== a 's) (== b 's))
   ((== a 't) (== b 't))
   ((== a 'u) (== b 'u))
   ((== a 'v) (== b 'v))
   ((== a 'w) (== b 'w))
   ((== a 'x) (== b 'x))
   ((== a 'y) (== b 'y))
   ((== a 'z) (== b 'z))
   ((== a 'A) (== b 'a))
   ((== a 'B) (== b 'b))
   ((== a 'C) (== b 'c))
   ((== a 'D) (== b 'd))
   ((== a 'E) (== b 'e))
   ((== a 'F) (== b 'f))
   ((== a 'G) (== b 'g))
   ((== a 'H) (== b 'h))
   ((== a 'I) (== b 'i))
   ((== a 'J) (== b 'j))
   ((== a 'K) (== b 'k))
   ((== a 'L) (== b 'l))
   ((== a 'M) (== b 'm))
   ((== a 'N) (== b 'n))
   ((== a 'O) (== b 'o))
   ((== a 'P) (== b 'p))
   ((== a 'Q) (== b 'q))
   ((== a 'R) (== b 'r))
   ((== a 'S) (== b 's))
   ((== a 'T) (== b 't))
   ((== a 'U) (== b 'u))
   ((== a 'V) (== b 'v))
   ((== a 'W) (== b 'w))
   ((== a 'X) (== b 'x))
   ((== a 'Y) (== b 'y))
   ((== a 'Z) (== b 'z))
   ((== a '0) (== b '0))
   ((== a '1) (== b '1))
   ((== a '2) (== b '2))
   ((== a '3) (== b '3))
   ((== a '4) (== b '4))
   ((== a '5) (== b '5))
   ((== a '6) (== b '6))
   ((== a '7) (== b '7))
   ((== a '8) (== b '8))
   ((== a '9) (== b '9))))

(define-relation (chars-to-uppero lower upper)
  (fresh (lower-car lower-cdr upper-car upper-cdr)
         (conde
          ((== lower `())
           (== upper `()))
          ((== lower `(,lower-car . ,lower-cdr))
           (== upper `(,upper-car . ,upper-cdr))
           (char-to-uppero lower-car upper-car)
           (chars-to-uppero lower-cdr upper-cdr)))))

(define-relation (chars-to-lowero upper lower)
  (fresh (lower-car lower-cdr upper-car upper-cdr)
         (conde
          ((== lower `())
           (== upper `()))
          ((== lower `(,lower-car . ,lower-cdr))
           (== upper `(,upper-car . ,upper-cdr))
           (char-to-lowero upper-car lower-car)
           (chars-to-lowero upper-cdr lower-cdr)))))

(comment
 (run 1 (a b) (chars-to-lowero '(E R I C) b))
 ;; => '((_.0 (e r i c)))
 )

(comment

 (run 100 (fn arg out) (eval-expo `(app ,fn ,arg) '() out))

 )
